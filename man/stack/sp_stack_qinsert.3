.\"  Staple - A general-purpose data structure library in pure C89.
.\"  Copyright (C) 2021  Randoragon
.\"
.\"  This library is free software; you can redistribute it and/or
.\"  modify it under the terms of the GNU Lesser General Public
.\"  License as published by the Free Software Foundation;
.\"  version 2.1 of the License.
.\"
.\"  This library is distributed in the hope that it will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.\"  Lesser General Public License for more details.
.\"
.\"  You should have received a copy of the GNU Lesser General Public
.\"  License along with this library; if not, write to the Free Software
.\"  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
.\"--------------------------------------------------------------------------------
.TH SP_STACK_QINSERT 3 DATE "libstaple-VERSION"
.SH NAME
sp_stack_qinsert,
sp_stack_qinsertc,
sp_stack_qinserts,
sp_stack_qinserti,
sp_stack_qinsertl,
sp_stack_qinsertsc,
sp_stack_qinsertuc,
sp_stack_qinsertus,
sp_stack_qinsertui,
sp_stack_qinsertul,
sp_stack_qinsertf,
sp_stack_qinsertd,
sp_stack_qinsertld,
sp_stack_qinsertll,
sp_stack_qinsertull,
sp_stack_qinsertu8,
sp_stack_qinsertu16,
sp_stack_qinsertu32,
sp_stack_qinsertu64,
sp_stack_qinserti8,
sp_stack_qinserti16,
sp_stack_qinserti32,
sp_stack_qinserti64,
sp_stack_qinsertstr,
sp_stack_qinsertstrn
\- quickly insert an element at any position of a stack
.SH SYNOPSIS
.ad l
#include <staple.h>
.sp
int
.BR sp_stack_qinsert "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
const void
.RI * elem )
.br
int
.BR sp_stack_qinsertc "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
char
.IR elem )
.br
int
.BR sp_stack_qinserts "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
short
.IR elem )
.br
int
.BR sp_stack_qinserti "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
int
.IR elem )
.br
int
.BR sp_stack_qinsertl "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
long
.IR elem )
.br
int
.BR sp_stack_qinsertsc "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
signed char
.IR elem )
.br
int
.BR sp_stack_qinsertuc "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned char
.IR elem )
.br
int
.BR sp_stack_qinsertus "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned short
.IR elem )
.br
int
.BR sp_stack_qinsertui "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned int
.IR elem )
.br
int
.BR sp_stack_qinsertul "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned long
.IR elem )
.br
int
.BR sp_stack_qinsertf "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
float
.IR elem )
.br
int
.BR sp_stack_qinsertd "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
double
.IR elem )
.br
int
.BR sp_stack_qinsertld "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
long double
.IR elem )
.br
int
.BR sp_stack_qinsertll "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
long long
.IR elem )
.br
int
.BR sp_stack_qinsertull "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned long long
.IR elem )
.br
int
.BR sp_stack_qinsertu8 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
uint8_t
.IR elem )
.br
int
.BR sp_stack_qinsertu16 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
uint16_t
.IR elem )
.br
int
.BR sp_stack_qinsertu32 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
uint32_t
.IR elem )
.br
int
.BR sp_stack_qinsertu64 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
uint64_t
.IR elem )
.br
int
.BR sp_stack_qinserti8 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
int8_t
.IR elem )
.br
int
.BR sp_stack_qinserti16 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
int16_t
.IR elem )
.br
int
.BR sp_stack_qinserti32 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
int32_t
.IR elem )
.br
int
.BR sp_stack_qinserti64 "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
int64_t
.IR elem )
.br
int
.BR sp_stack_qinsertstr "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
const char
.RI * elem )
.br
int
.BR sp_stack_qinsertstrn "(struct sp_stack"
.RI * stack ,
size_t
.IR idx ,
const char
.RI * elem ,
size_t
.IR len )
.sp
Link with \fI-lstaple\fP.
.ad
.SH DESCRIPTION
See
.BR sp_stack_insert (3).
.P
The functions in the
.BR sp_stack_qinsert ()
family operate in constant time, which is achievable by changing the order of
the elements upon insertion.
.SH CONFORMING TO
See
.BR libstaple (7).
.SH EXAMPLES
To explain how the
.BR sp_stack_insert ()
and
.BR sp_stack_qinsert ()
families differ, consider the following initial stack (elements listed
from bottom to top):
.IP
.B 1 2 3 4 _ _ _
.P
Now, let us investigate what happens when we try to insert the number
.B 5
at position
.IR 2 .
.P
The functions in the
.BR sp_stack_insert ()
family would move
.BR 3 " and " 4
upwards, and insert
.B 5
without altering the order:
.IP (1)
.B 1 2 _ 3 4 _ _
.br
\h'6n'^ ^
.IP (2)
.B 1 2 5 3 4 _ _
.br
\h'4n'^
.P
On the contrary, the functions in the
.BR sp_stack_qinsert ()
family achieve the goal faster by moving the element "in the way" (in this case
.BR 3 )
to the top of the stack:
.IP (1)
.B 1 2 _ 4 3 _ _
.br
\h'8n'^
.IP (2)
.B 1 2 5 4 3 _ _
.br
\h'4n'^
.P
The second approach guarantees constant time, but does not preserve the order of
the elements.
.SH SEE ALSO
.ad l
.BR libstaple (7),
.BR sp_stack (7),
.BR sp_stack_create (3),
.BR sp_stack_destroy (3),
.BR sp_stack_clear (3),
.BR sp_stack_push (3),
.BR sp_stack_peek (3),
.BR sp_stack_pop (3),
.BR sp_stack_insert (3),
.BR sp_stack_remove (3),
.BR sp_stack_qremove (3),
.BR sp_stack_get (3),
.BR sp_stack_set (3),
.BR sp_stack_eq (3),
.BR sp_stack_copy (3),
.BR sp_stack_map (3),
.BR sp_stack_print (3)
